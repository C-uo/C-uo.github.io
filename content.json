{"pages":[],"posts":[{"title":"利用xeCJK包解决Tex中他语言文字乱码问题","text":"总所周知中文和日文中有很多相似甚至相同的汉字。同样的中文和日文中也存在很多独有的文字。 如果我们的文章中同时含有中文与日文。那么在我们使用LaTex给这些文章进行排版时，就很容易出现文字乱码的情况。 这时我们就需要为另一种语言指定合适的字体来避免这种情况的出现。具体的做法也非常简单 123456789101112\\documentclass[11pt, titlepage]{report}\\usepackage{xeCJK}% ...\\setCJKmainfont{IPAexMincho}\\setCJKsansfont{IPAexGothic}\\setCJKmonofont{IPAexGothic}% ...% 指定另一种语言的字体（在这里使用宋体）\\newCJKfontfamily\\zh{STSongti-SC-Regular} \\begin{document}「石橋を叩いて渡る」を中国語に訳すと「{\\zh 小心使得万年船}」になる。\\end{document}","link":"/2020/01/01/%E5%88%A9%E7%94%A8xeCJK%E5%8C%85%E8%A7%A3%E5%86%B3Tex%E4%B8%AD%E4%BB%96%E8%AF%AD%E8%A8%80%E6%96%87%E5%AD%97%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"},{"title":"如何在LaTex中给文字注音","text":"在我们给文章排版时，可能会想要给某些文字标注读音。这个时候我们就可以使用pxrubrica包来方便的实现这一目的。 效果展示123456\\documentclass[11pt, titlepage]{report}\\usepackage{xeCJK} %因为我使用了UTF-8的字符，所以导入xeCJK包\\usepackage{pxrubrica}\\begin{document}\\ruby{立命馆}{lì| mìng| guǎn} \\ruby{立命館}{りつ|めい|かん}\\end{document} 用法说明 给单个文字注音 \\ruby{A}{A的注音} 需要给多个文字分别注音（例如效果展示）时，则应使用｜来给注音划分段落。 \\ruby{ A B }{ A的注音｜B的注音} 或者使用[g]给所有文字同时注音。 \\ruby[g]{ A B }{ A的注音 B的注音 } tip: 利用[g]的方法，你甚至可以在罗马字的上方进行注释","link":"/2020/01/01/%E5%A6%82%E4%BD%95%E5%9C%A8LaTex%E4%B8%AD%E7%BB%99%E6%96%87%E5%AD%97%E6%B3%A8%E9%9F%B3/"},{"title":"Swift学习笔记","text":"该記事主要记录了我在学习Swift时觉得有趣的内容或是与其他语言的对比 字符串插值string interpolation在python并不存在这样的写法。123var name = \"Cuo\"print(\"I'm \\(name)\")>> \"I'm Cuo\\n\" TypeSwift会默认推断浮点数的类型时Double 数值字面量可以在数值中添加0或_，这并不会改变数值var hoge = 00_012.233 函数在Swift中函数的定义略显特殊123func functionName(parameterName: parameterType) -> returnType{ mainCode}除了制定参数的Type外, 还需要显示的声明返回值的类型.而在引用函数时则需要像functionName(parameterName: parameter)这样显示的写出参数名。若想使用位置参数, 则需要在定义函数时在变量名前加上”_ “eg. (_ parameterName) 类/对象在Swift中定义Class的方法如下1234567891011121314151617181920212223class ClassName: ParentClass{ // 声明属性, 所有的属性都必须被赋值 let constantProperty: Type = something // 可通过声明来赋值 var variableProperty: Type // 也可以先声明, 然后通过构造器赋值 init(variableProperty: Type){ // 通过构造器赋值 self.variableProperty = variableProperty // 将构造器参数赋值给实例变量 super.init(parentClassProperty: parameter) // 继承父类构造器 parentClassProperty = something // 改变父类中通过声明赋值的属性的值 } var otherProperty: Type { get { do something } // 在Swift中你可以使用计算属性; 可以轻松的监测值的变化 set { do something } // get, set可以在构造器初始化类实例时工作 willSet { do something } // willSet, didSet虽不能监测到构造器中发生值的情况 didSet { do something } // 但能在设置新值之前或之后工作 } // 继承方法 override func parentClassFunc() -> returnType{ // 注意override的位置与写法 function body }}这一步分中最大的亮点应该就是计算属性了。通过这种机制可以在监测某些值的变化, 并在变化后轻松的做出相应动作。别的注意点则是override的位置, 构造器不需要作为一个方法来定义。 协议和扩展用 protocol来声明一个协议。协议是用来限定或者说为类，枚举，结构体制定标准的语法。 数组 [Arrays] 集合 字典a == a(自反性)a == b意味着 b == a(对称性)a == b && b == c意味着 a == c(传递性) Arrays数组是可以遍历的，同样的您也可以使用enumerated()方法使其返回索引与数据值。1var favoriteGenres = [\"Jazz\", \"Classical\", \"Hip hop\"]Arrays.remove(at: Int) Set集合是无序的，且每个值都应是独一无二的（遵循Hashable协议）。与数组相同集合也是可遍历的，若想按照特定的顺序遍历集合中的值可以使用sorted()。1var favoriteGenres:Set = [\"Jazz\", \"Classical\", \"Hip hop\"] 基本集合操作a AND b a.intersection(b)NOT a AND b a.symmetricDifference(b)a OR b a.union(b)a not b a.subtracting(b)判断全等 ==判断子集 isSubset(of: )etc…… Dictionary字典的Key也应是独一无二的（遵循Hashable协议）。123var namesOfIntegers = [Int: String]()namesOfIntegers[16] = \"sixteen\"var otherNameOfIntegers = [16: \"sixteen\"] // 推奨 Loopstride(from: to: by: ) 半开区间stride(from: through: by: ) 闭区间该方法可以指定区间与步进。 eg. stride(from: 0, to: 60, by: 5) switchcase分支用where来判断额外条件12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint {case let (x, y) where x == y: print(\"(\\(x), \\(y)) is on the line x == y\")case let (x, y) where x == -y: print(\"(\\(x), \\(y)) is on the line x == -y\")case let (x, y): print(\"(\\(x), \\(y)) is just some arbitrary point\")}// 输出“(1, -1) is on the line x == -y” 复合型Cases如果多种条件可以使用同一方法处理时，可以将这些条件用逗号隔开，放置于同一case后。这种写法称为复合型Cases","link":"/2020/01/02/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"关于Ruby中0除以浮点数的坑","text":"Ruby中用0除以整数时解释器会丢出ZeroDivisionError的错误。 这没有问题，很符合我们的直觉。 1234irb(main):001:0> 114154/0Traceback (most recent call last): 1: from(irb):1 ……ZeroDivisionError (divided by 0) 但用0除以浮点数时情况就不一样了。 12irb(main):002:0> 1.1/0=> Infinity 解释器没有抛出error，反而返回了Infinity 顺带一提，在JS中0除以任何数都返回Infinity 而在Python中则会抛出ZeroDivisionError: float division by zero","link":"/2020/01/09/%E5%85%B3%E4%BA%8ERuby%E4%B8%AD0%20%E9%99%A4%E4%BB%A5%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"Tex","slug":"Tex","link":"/tags/Tex/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"Ruby","slug":"Ruby","link":"/tags/Ruby/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"}]}